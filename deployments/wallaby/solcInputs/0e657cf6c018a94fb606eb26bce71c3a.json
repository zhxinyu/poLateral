{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author EthanZ\n * @notice Defines the basic interface for an FIL Lending Pool.\n **/\n interface IPool{\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the sFILs\n   * @param amount The amount supplied\n   **/\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount\n  );\n\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of sFILs\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using sFILs, `false` if done with underlying asset directly\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @notice Supplies an `amount` of underlying asset FIL into the reserve, receiving in return overlying aFIL.\n   * - E.g. User supplies 100 FIL and gets in return 100 aFIL\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aFIL, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aFIL\n   *   is a different wallet\n   **/\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aFIL, calls withdraw() and receives 100 FIL, burning the 100 aFIL\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  // /**\n  //  * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n  //  * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n  //  * corresponding debt token (StableDebtToken or VariableDebtToken)\n  //  * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n  //  *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n  //  * @param asset The address of the underlying asset to borrow\n  //  * @param amount The amount to be borrowed\n  //  * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n  //  * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n  //  * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n  //  * if he has been given credit delegation allowance\n  //  **/\n  // function borrow(\n  //   address asset,\n  //   uint256 amount,\n  //   uint256 interestRateMode,\n  //   address onBehalfOf\n  // ) external;\n\n  // /**\n  //  * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n  //  * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n  //  * @param asset The address of the borrowed underlying asset previously borrowed\n  //  * @param amount The amount to repay\n  //  * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n  //  * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n  //  * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n  //  * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n  //  * other borrower whose debt should be removed\n  //  * @return The final amount repaid\n  //  **/\n  // function repay(\n  //   address asset,\n  //   uint256 amount,\n  //   uint256 interestRateMode,\n  //   address onBehalfOf\n  // ) external returns (uint256);\n\n  // /**\n  //  * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n  //  * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n  //  *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n  //  * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n  //  * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n  //  * @param user The address of the borrower getting liquidated\n  //  * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n  //  * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n  //  * to receive the underlying collateral asset directly\n  //  **/\n  // function liquidationCall(\n  //   address collateralAsset,\n  //   address debtAsset,\n  //   address user,\n  //   uint256 debtToCover,\n  //   bool receiveAToken\n  // ) external;\n\n  // /**\n  //  * @notice Returns the list of the underlying assets of all the initialized reserves\n  //  * @dev It does not include dropped reserves\n  //  * @return The addresses of the underlying assets of the initialized reserves\n  //  **/\n  // function getReserves() external view returns (address);\n\n  // /**\n  //  * @notice Rescue and transfer tokens locked in this contract\n  //  * @param token The address of the token\n  //  * @param to The address of the recipient\n  //  * @param amount The amount of token to transfer\n  //  */\n  // function rescueTokens(\n  //   address token,\n  //   address to,\n  //   uint256 amount\n  // ) external;\n  \n }"
    },
    "contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary DataTypes {\n\n  enum InterestRateMode {\n    NONE\n  }\n\n  struct ReserveData {\n  //sFIL address\n  address sFILAddress;\n  //timestamp of last update\n  uint40 lastUpdateTimestamp;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n  }\n\n  struct ReserveCache {\n    address sFILAddress;\n    uint40 reserveLastUpdateTimestamp;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n  }\n\n}"
    },
    "contracts/protocol/pool/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {IPool} from \"../../interfaces/IPool.sol\";\nimport {SupplyLogic} from '../libraries/logic/SupplyLogic.sol';\nimport {PoolStorage} from './PoolStorage.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\n\ncontract Pool is PoolStorage, IPool {\n    address public immutable poolOwner;\n\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     */\n    constructor(address provider) {\n        poolOwner = provider;\n    }\n\n    /**\n     * @notice Map from FILAddress to sFILAddress.\n     * @param FILAddress FIL address\n     * @param sFILAddress The address of the overlying sFILAddress contract\n     **/\n    function init(\n        address FILAddress,\n        address sFILAddress\n    ) internal {\n        require(_reserves[FILAddress].sFILAddress == address(0), Errors.RESERVE_ALREADY_INITIALIZED);\n        _reserves[FILAddress].sFILAddress = sFILAddress;\n    }\n\n    /// @inheritdoc IPool\n    function supply(\n        address asset,\n        uint256 amount,\n        address onBehalfOf\n    ) public virtual override {\n        SupplyLogic.executeSupply(\n            _reserves,\n            DataTypes.ExecuteSupplyParams({\n                asset: asset,\n                amount: amount,\n                onBehalfOf: onBehalfOf\n            })\n        );\n    }\n\n    /// @inheritdoc IPool\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) public virtual override returns (uint256) {\n        return\n        SupplyLogic.executeWithdraw(\n            _reserves,\n            DataTypes.ExecuteWithdrawParams({\n            asset: asset,\n            amount: amount,\n            to: to\n            })\n        );\n    }\n\n}\n"
    },
    "contracts/protocol/libraries/logic/SupplyLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IWFIL} from '../../../interfaces/IWFIL.sol';\nimport {IsFIL} from '../../../interfaces/IsFIL.sol';\n\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\n\n/**\n * @title SupplyLogic library\n * @author Aave\n * @notice Implements the base logic for supply/withdraw\n */\nlibrary SupplyLogic {\n\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @notice Implements the supply feature. Through `supply()`, users supply assets to the Aave protocol.\n   * @dev In the first supply action, `ReserveUsedAsCollateralEnabled()` is emitted, if the asset can be enabled as\n   * collateral.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the supply function\n   */\n  function executeSupply(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteSupplyParams memory params\n  ) external {\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    reserve.updateState();\n\n    ValidationLogic.validateSupply(params.amount);\n\n    IWFIL(params.asset).transferFrom(reserve.sFILAddress, params.amount);\n\n    IsFIL(reserve.sFILAddress).mint(msg.sender, params.onBehalfOf, params.amount);\n\n  }\n\n/**\n   * @notice Implements the withdraw feature. Through `withdraw()`, users redeem their sFILs for the underlying asset\n   * previously supplied in the protocol.\n   * @param reservesData The state of all the reserves\n   * @param params The additional parameters needed to execute the withdraw function\n   * @return The actual amount withdrawn\n   */\n  function executeWithdraw(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.ExecuteWithdrawParams memory params\n  ) external returns (uint256) {\n\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    reserve.updateState();\n\n    uint256 userBalance = IsFIL(reserve.sFILAddress).balanceOf(msg.sender);\n\n    uint256 amountToWithdraw = params.amount;\n\n    if (params.amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(amountToWithdraw, userBalance);\n\n    IsFIL(reserve.sFILAddress).burn(msg.sender, amountToWithdraw);\n\n    IWFIL(reserve.sFILAddress).transferFrom(params.to, amountToWithdraw);\n\n    return amountToWithdraw;\n  }\n\n}"
    },
    "contracts/protocol/pool/PoolStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\n\n/**\n * @title PoolStorage\n * @notice Contract used as storage of the Pool contract.\n * @dev It defines the storage layout of the Pool contract.\n */\ncontract PoolStorage {\n  using ReserveLogic for DataTypes.ReserveData;\n\n  // Map of reserves and their data (underlyingAssetOfReserve => reserveData)\n  mapping(address => DataTypes.ReserveData) internal _reserves;\n\n}\n"
    },
    "contracts/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/**\n * @title Errors library\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_ADMIN = '1'; // 'The caller of the function is not a pool admin'\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '2'; // 'The caller of the function is not an emergency admin'\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = '3'; // 'The caller of the function is not a pool or emergency admin'\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = '4'; // 'The caller of the function is not a risk or pool admin'\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant CALLER_NOT_BRIDGE = '6'; // 'The caller of the function is not a bridge'\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = '7'; // 'Pool addresses provider is not registered'\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = '8'; // 'Invalid id for the pool addresses provider'\n  string public constant NOT_CONTRACT = '9'; // 'Address is not a contract'\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\n  string public constant CALLER_NOT_ATOKEN = '11'; // 'The caller of the function is not an AToken'\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = '13'; // 'Invalid return value of the flashloan executor function'\n  string public constant RESERVE_ALREADY_ADDED = '14'; // 'Reserve has already been added to reserve list'\n  string public constant NO_MORE_RESERVES_ALLOWED = '15'; // 'Maximum amount of reserves in the pool reached'\n  string public constant EMODE_CATEGORY_RESERVED = '16'; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = '17'; // 'Invalid eMode category assignment to asset'\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = '18'; // 'The liquidity of the reserve needs to be 0'\n  string public constant FLASHLOAN_PREMIUM_INVALID = '19'; // 'Invalid flashloan premium'\n  string public constant INVALID_RESERVE_PARAMS = '20'; // 'Invalid risk parameters for the reserve'\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = '21'; // 'Invalid risk parameters for the eMode category'\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = '22'; // 'Invalid bridge protocol fee'\n  string public constant CALLER_MUST_BE_POOL = '23'; // 'The caller of this function must be a pool'\n  string public constant INVALID_MINT_AMOUNT = '24'; // 'Invalid amount to mint'\n  string public constant INVALID_BURN_AMOUNT = '25'; // 'Invalid amount to burn'\n  string public constant INVALID_AMOUNT = '26'; // 'Amount must be greater than 0'\n  string public constant RESERVE_INACTIVE = '27'; // 'Action requires an active reserve'\n  string public constant RESERVE_FROZEN = '28'; // 'Action cannot be performed because the reserve is frozen'\n  string public constant RESERVE_PAUSED = '29'; // 'Action cannot be performed because the reserve is paused'\n  string public constant BORROWING_NOT_ENABLED = '30'; // 'Borrowing is not enabled'\n  string public constant STABLE_BORROWING_NOT_ENABLED = '31'; // 'Stable borrowing is not enabled'\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = '32'; // 'User cannot withdraw more than the available balance'\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = '33'; // 'Invalid interest rate mode selected'\n  string public constant COLLATERAL_BALANCE_IS_ZERO = '34'; // 'The collateral balance is 0'\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '35'; // 'Health factor is lesser than the liquidation threshold'\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = '36'; // 'There is not enough collateral to cover a new borrow'\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = '37'; // 'Collateral is (mostly) the same currency that is being borrowed'\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '38'; // 'The requested amount is greater than the max loan size in stable rate mode'\n  string public constant NO_DEBT_OF_SELECTED_TYPE = '39'; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '40'; // 'To repay on behalf of a user an explicit amount to repay is needed'\n  string public constant NO_OUTSTANDING_STABLE_DEBT = '41'; // 'User does not have outstanding stable rate debt on this reserve'\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = '42'; // 'User does not have outstanding variable rate debt on this reserve'\n  string public constant UNDERLYING_BALANCE_ZERO = '43'; // 'The underlying balance needs to be greater than 0'\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '44'; // 'Interest rate rebalance conditions were not met'\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '45'; // 'Health factor is not below the threshold'\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = '46'; // 'The collateral chosen cannot be liquidated'\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '47'; // 'User did not borrow the specified currency'\n  string public constant SAME_BLOCK_BORROW_REPAY = '48'; // 'Borrow and repay in same block is not allowed'\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = '49'; // 'Inconsistent flashloan parameters'\n  string public constant BORROW_CAP_EXCEEDED = '50'; // 'Borrow cap is exceeded'\n  string public constant SUPPLY_CAP_EXCEEDED = '51'; // 'Supply cap is exceeded'\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = '52'; // 'Unbacked mint cap is exceeded'\n  string public constant DEBT_CEILING_EXCEEDED = '53'; // 'Debt ceiling is exceeded'\n  string public constant ATOKEN_SUPPLY_NOT_ZERO = '54'; // 'AToken supply is not zero'\n  string public constant STABLE_DEBT_NOT_ZERO = '55'; // 'Stable debt supply is not zero'\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = '56'; // 'Variable debt supply is not zero'\n  string public constant LTV_VALIDATION_FAILED = '57'; // 'Ltv validation failed'\n  string public constant INCONSISTENT_EMODE_CATEGORY = '58'; // 'Inconsistent eMode category'\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = '59'; // 'Price oracle sentinel validation failed'\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = '60'; // 'Asset is not borrowable in isolation mode'\n  string public constant RESERVE_ALREADY_INITIALIZED = '61'; // 'Reserve has already been initialized'\n  string public constant USER_IN_ISOLATION_MODE = '62'; // 'User is in isolation mode'\n  string public constant INVALID_LTV = '63'; // 'Invalid ltv parameter for the reserve'\n  string public constant INVALID_LIQ_THRESHOLD = '64'; // 'Invalid liquidity threshold parameter for the reserve'\n  string public constant INVALID_LIQ_BONUS = '65'; // 'Invalid liquidity bonus parameter for the reserve'\n  string public constant INVALID_DECIMALS = '66'; // 'Invalid decimals parameter of the underlying asset of the reserve'\n  string public constant INVALID_RESERVE_FACTOR = '67'; // 'Invalid reserve factor parameter for the reserve'\n  string public constant INVALID_BORROW_CAP = '68'; // 'Invalid borrow cap for the reserve'\n  string public constant INVALID_SUPPLY_CAP = '69'; // 'Invalid supply cap for the reserve'\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = '70'; // 'Invalid liquidation protocol fee for the reserve'\n  string public constant INVALID_EMODE_CATEGORY = '71'; // 'Invalid eMode category for the reserve'\n  string public constant INVALID_UNBACKED_MINT_CAP = '72'; // 'Invalid unbacked mint cap for the reserve'\n  string public constant INVALID_DEBT_CEILING = '73'; // 'Invalid debt ceiling for the reserve\n  string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = '75'; // 'ACL admin cannot be set to the zero address'\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\n  string public constant INVALID_EXPIRATION = '78'; // 'Invalid expiration'\n  string public constant INVALID_SIGNATURE = '79'; // 'Invalid signature'\n  string public constant OPERATION_NOT_SUPPORTED = '80'; // 'Operation not supported'\n  string public constant DEBT_CEILING_NOT_ZERO = '81'; // 'Debt ceiling is not zero'\n  string public constant ASSET_NOT_LISTED = '82'; // 'Asset is not listed'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = '84'; // 'Invalid optimal stable to total debt ratio'\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = '85'; // 'The underlying asset cannot be rescued'\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = '86'; // 'Reserve has already been added to reserve list'\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = '87'; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n  string public constant STABLE_BORROWING_ENABLED = '88'; // 'Stable borrowing is enabled'\n  string public constant SILOED_BORROWING_VIOLATION = '89'; // 'User is trying to borrow multiple assets including a siloed one'\n  string public constant RESERVE_DEBT_NOT_ZERO = '90'; // the total debt of the reserve needs to be 0\n}\n"
    },
    "contracts/interfaces/IWFIL.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IWFIL {\n\n  function transferFrom(address to, uint256 amount) external returns(bool);\n}"
    },
    "contracts/interfaces/IsFIL.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IsFIL {\n\n    function mint(address caller, address onBehalfOf, uint256 amount) external returns (bool);\n\n    function burn(address from, uint256 amount) external;\n\n    function balanceOf(address user) external view returns (uint256);\n\n\n}"
    },
    "contracts/protocol/libraries/logic/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n// import {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\n// import {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\n// import {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\n// import {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\n// import {MathUtils} from '../math/MathUtils.sol';\n// import {WadRayMath} from '../math/WadRayMath.sol';\n// import {PercentageMath} from '../math/PercentageMath.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n// import {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements the logic to update the reserves state\n */\nlibrary ReserveLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n\n  /**\n   * @notice Updates the liquidity cumulative index and the variable borrow index.\n   * @param reserve The reserve object\n   **/\n  function updateState(\n    DataTypes.ReserveData storage reserve\n  ) internal {\n    _updateIndexes(reserve);\n  }\n\n\n  /**\n   * @notice Updates the reserve indexes and the timestamp of the update.\n   * @param reserve The reserve reserve to be updated\n   **/\n  function _updateIndexes(\n    DataTypes.ReserveData storage reserve\n  ) internal {\n    //solium-disable-next-line\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\n  }\n\n}\n"
    },
    "contracts/protocol/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  /**\n   * @notice Validates a supply action.\n   * @param amount The amount to be supplied\n   */\n  function validateSupply(uint256 amount)\n    internal\n    pure \n  {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n  }\n\n  /**\n   * @notice Validates a withdraw action.\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    uint256 amount,\n    uint256 userBalance\n  ) internal pure {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n  }\n\n}\n"
    },
    "contracts/tokenization/sFIL.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {IsFIL} from '../interfaces/IsFIL.sol';\n\ncontract sFIL is IsFIL {\n  \n        mapping (address => uint256) balances;\n        address public immutable ADMIN;\n\n        constructor(address poolAddress) {\n            require(poolAddress != address(0), \"\");\n            ADMIN = poolAddress;\n        }\n\n        function mint(address caller,\n                             address onBehalfOf,\n                             uint256 amount) external returns (bool) {\n          require(ADMIN != address(0), \"\");                         \n          require(msg.sender == ADMIN);\n          balances[onBehalfOf]+=amount;\n          return true;\n        }\n\n        function burn(address from, uint256 amount) external  {\n            require(ADMIN != address(0), \"\");                         \n            require(msg.sender == ADMIN);\n            balances[from]-=amount;\n        }\n\n        function balanceOf(address user) external view returns (uint256){\n          return balances[user];\n        }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}